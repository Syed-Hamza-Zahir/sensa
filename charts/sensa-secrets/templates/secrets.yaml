{{- $root := . -}}
---
apiVersion: v1
kind: Secret
metadata:
  name: "{{ .Values.sensaSecrets }}"
type: Opaque
stringData:
# Run password validation to ensure supplied password meets our criteria.  Chart will fail if criteria not met.
  {{ include "validPass" . }}
# retrieve the secret data using lookup function and when not exists, return an empty dictionary / map as result
  {{- $secretObj := (lookup "v1" "Secret" .Release.Namespace .Values.sensaSecrets) | default dict }}
  {{- $secretData := (get $secretObj "data") | default dict }}
# set $servicesPassword to existing secret data or generate a random one when not exists
  {{- $servicesPassword := (get $secretData "SENSA_SERVICES_PASSWORD" | b64dec) | default (randAlphaNum 12) }}
# set $encryptSecret to existing secret data or generate a random one when not exists
  {{- $encryptSecret := (get $secretData "SENSA_ENCRYPTION_SECRET" | b64dec) | default (randAlphaNum 12) }}
# set $jwtAccessSecret to existing secret data or generate a random one when not exists
  {{- $jwtAccessSecret := (get $secretData "SENSA_JWT_ACCESS_SECRET" | b64dec) | default (randAlphaNum 12) }}
# set $jwtRefreshSecret to existing secret data or generate a random one when not exists
  {{- $jwtRefreshSecret := (get $secretData "SENSA_JWT_REFRESH_SECRET" | b64dec) | default (randAlphaNum 12) }}
  config.yaml: |
  SENSA_API_KEY_SECRET: "{{ .Values.global.PASSWORD }}"
  SENSA_DB_PASSWORD: "{{ $servicesPassword }}"
  SENSA_DB_URL: "{{ .Values.global.DB_TYPE }}://{{ .Values.global.DB_USER }}:{{ $servicesPassword }}@{{ .Values.global.DB_TYPE }}:{{ .Values.global.DB_PORT }}/ayasdi"
  SENSA_ENCRYPTION_SECRET: "{{ $encryptSecret }}"
  SENSA_JWT_ACCESS_SECRET: "{{ $jwtAccessSecret }}"
  SENSA_JWT_REFRESH_SECRET: "{{ $jwtRefreshSecret }}"
  SENSA_RABBIT_MQ_URL: "amqp://user:{{ $servicesPassword }}@rabbitmq:5627"
  SENSA_REDIS_URL: "redis://:{{ $servicesPassword }}@redis-master:6379"
  SENSA_S3_URL: "http://{{ .Values.global.MINIO_USER }}:{{ $servicesPassword }}@minio:9000"
  SENSA_SERVICES_PASSWORD: "{{ $servicesPassword }}"
  SENSA_TRINO_URL: "https://{{ .Values.global.DATALAKE_SERVICE_USER }}:{{ $servicesPassword }}@{{ .Values.global.DATALAKE_INGRESS_HOST }}:{{ .Values.global.sslPort }}?catalog=iceberg&schema=sensa"
  SENSA_USER_PASSWORD: "{{ .Values.global.PASSWORD }}"
---
apiVersion: v1
kind: Secret
metadata:
  name: "{{ .Values.prometheusSecret }}"
type: Opaque
data:
  auth: {{ htpasswd .Values.global.DATALAKE_USER .Values.global.PASSWORD | b64enc }}
---
apiVersion: v1
kind: Secret
metadata:
  name: "{{ .Values.trinoSecret }}"
  labels:
    {{- include "trino.labels" . | nindent 4 }}
type: Opaque
stringData:
  password.db: |
    {{ htpasswd .Values.global.DATALAKE_USER .Values.global.PASSWORD | replace "$2a$" "$2y$" }}
    {{ htpasswd .Values.global.DATALAKE_SERVICE_USER $servicesPassword | replace "$2a$" "$2y$" }}
---
apiVersion: v1
kind: Secret
metadata:
  name: "{{ .Values.postgresSecret }}"
type: Opaque
stringData:
  config.yaml: |
  postgres-password: "{{ $servicesPassword }}"
  password: "{{ $servicesPassword }}"
  replicationPasswordKey: "{{ $servicesPassword }}"
---
apiVersion: v1
kind: Secret
metadata:
  name: "{{ .Values.minioSecret }}"
type: Opaque
stringData:
  config.yaml: |
  root-user: "{{ .Values.global.MINIO_USER }}"
  root-password: "{{ $servicesPassword }}"
---
apiVersion: v1
kind: Secret
metadata:
  name: "{{ .Values.redisSecret }}"
type: Opaque
stringData:
  config.yaml: |
  redis-user: "{{ .Values.global.DB_USER }}"
  password: "{{ $servicesPassword }}"
---
apiVersion: v1
kind: Secret
metadata:
  name: "{{ .Values.rabbitmqSecret }}"
type: Opaque
stringData:
# retrieve the secret data using lookup function and when not exists, return an empty dictionary / map as result
  {{- $secretObj := (lookup "v1" "Secret" .Release.Namespace .Values.rabbitmqSecret) | default dict }}
  {{- $secretData := (get $secretObj "data") | default dict }}
# set $erlangCookie to existing secret data or generate a random one when not exists
  {{- $erlangCookie := (get $secretData "rabbitmq-erlang-cookie" | b64dec) | default (randAlphaNum 12) }}
  config.yaml: |
  rabbitmq-password: "{{ $servicesPassword }}"
  rabbitmq-erlang-cookie: "{{ $erlangCookie }}"
---
apiVersion: v1
kind: Secret
metadata:
  name: "{{ .Values.hiveSecret }}"
type: Opaque
stringData:
  hive.yaml: |
    rules:
    - pattern: '.*'
  metastore-site.xml: |
    <configuration>
        <property>
          <name>metastore.task.threads.always</name>
          <value>org.apache.hadoop.hive.metastore.events.EventCleanerTask</value>
        </property>
        <property>
          <name>metastore.expression.proxy</name>
          <value>org.apache.hadoop.hive.metastore.DefaultPartitionExpressionProxy</value>
        </property>
        <property>
          <name>metastore.storage.schema.reader.impl</name>
          <value>org.apache.hadoop.hive.metastore.SerDeStorageSchemaReader</value>
        </property>
        <property>
          <name>hive.metastore.uris</name>
          <value>thrift://hive-metastore:9083</value>
        </property>
        <property>
          <name>javax.jdo.option.ConnectionDriverName</name>
          <value>org.postgresql.Driver</value>
        </property>
        <property>
          <name>javax.jdo.option.ConnectionURL</name>
          <value>jdbc:postgresql://postgres:{{ .Values.global.DB_PORT }}/metastore_db</value>
        </property>
        <property>
          <name>javax.jdo.option.ConnectionUserName</name>
          <value>{{ .Values.global.HIVE_USER }}</value>
        </property>
        <property>
          <name>javax.jdo.option.ConnectionPassword</name>
          <value>{{ $servicesPassword }}</value>
        </property>
        <property>
          <name>fs.defaultFS</name>
          <value>s3a://minio:9000</value>
        </property>
        <property>
          <name>fs.s3a.connection.ssl.enabled</name>
          <value>false</value>
        </property>
        <property>
          <name>fs.s3a.impl</name>
          <value>org.apache.hadoop.fs.s3a.S3AFileSystem</value>
        </property>
        <property>
          <name>fs.s3a.endpoint</name>
          <value>http://minio:9000</value>
        </property>
        <property>
          <name>fs.s3a.access.key</name>
          <value>{{ .Values.global.MINIO_USER }}</value>
        </property>
        <property>
          <name>fs.s3a.secret.key</name>
          <value>{{ $servicesPassword }}</value>
        </property>
        <property>
          <name>fs.s3a.path.style.access</name>
          <value>true</value>
        </property>
        <property>
          <name>hive.metastore.metrics.enabled</name>
          <value>true</value>
        </property>
    </configuration>
---
apiVersion: v1
kind: Secret
metadata:
  name: trino-catalog
  labels:
    role: catalogs
type: Opaque
stringData:
  tpch.properties: |
    connector.name=tpch
    tpch.splits-per-node=4
  tpcds.properties: |
    connector.name=tpcds
    tpcds.splits-per-node=4
  minio.properties: |
    connector.name=hive
    hive.timestamp-precision=MICROSECONDS
    hive.max-partitions-per-writers=250
    hive.metastore.uri=thrift://hive-metastore:9083
    fs.native-s3.enabled=true
    s3.region=us-east-1
    s3.path-style-access=true
    s3.endpoint=http://minio:9000
    s3.aws-access-key={{ .Values.global.MINIO_USER }}
    s3.aws-secret-key={{ $servicesPassword }}
    hive.non-managed-table-writes-enabled=true
    hive.storage-format=PARQUET
  iceberg.properties: |
    connector.name=iceberg
    iceberg.file-format=PARQUET
    hive.metastore.uri=thrift://hive-metastore:9083
    fs.native-s3.enabled=true
    s3.region=us-east-1
    s3.path-style-access=true
    s3.endpoint=http://minio:9000
    s3.aws-access-key={{ .Values.global.MINIO_USER }}
    s3.aws-secret-key={{ $servicesPassword }}
  postgresql.properties: |
    connector.name=postgresql
    connection-url=jdbc:postgresql://postgres:{{ .Values.global.DB_PORT }}/ayasdi
    connection-user={{ .Values.global.DB_USER }}
    connection-password={{ $servicesPassword }}
    insert.non-transactional-insert.enabled=true
    postgresql.array-mapping=AS_ARRAY
    unsupported-type-handling=CONVERT_TO_VARCHAR
---
apiVersion: v1
kind: Secret
metadata:
  name: "{{ .Values.fluentSecret }}"
type: Opaque
stringData:
  config.yaml: |
  AWS_ACCESS_KEY_ID: "{{ .Values.global.MINIO_USER }}"
  AWS_SECRET_ACCESS_KEY: "{{ $servicesPassword }}"
